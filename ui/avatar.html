<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atomik Avatar</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        #status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        #status.visible {
            opacity: 1;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            text-align: center;
            z-index: 50;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .error {
            color: #ff6b6b;
        }
    </style>
</head>

<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Avatar y√ºkleniyor...</div>
    </div>
    <div id="status"></div>

    <!-- Scripts in correct order -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/dist/pixi.min.js"></script>
    <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/cubism4.min.js"></script>

    <script>
        const MODEL_PATH = 'model/arch chan model0.model3.json';

        // Fixed target height for avatar (percentage of window height)
        const AVATAR_HEIGHT_RATIO = 0.85; // Avatar fills 85% of window height

        let app = null;
        let model = null;
        let isReady = false;
        let idleTime = 0;
        let currentMouthValue = 0;
        let targetMouthValue = 0;
        let blinkTimer = 0;
        let nextBlinkTime = 3 + Math.random() * 2;
        let lastTime = performance.now();

        // Mouse tracking state
        let mouseX = 0.5; // 0-1 normalized
        let mouseY = 0.5;
        let targetEyeX = 0;
        let targetEyeY = 0;
        let targetHeadX = 0;
        let targetHeadY = 0;
        let currentEyeX = 0;
        let currentEyeY = 0;
        let currentHeadX = 0;
        let currentHeadY = 0;

        async function init() {
            const loadingEl = document.getElementById('loading');

            try {
                // Create PixiJS app
                app = new PIXI.Application({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    backgroundColor: 0x1a1a2e,
                    resolution: window.devicePixelRatio || 1,
                    autoDensity: true,
                });
                document.body.appendChild(app.view);

                loadingEl.innerHTML = '<div class="spinner"></div><div>Model y√ºkleniyor...</div>';

                // Load model using PIXI.live2d from cubism4.min.js
                const Live2DModel = PIXI.live2d?.Live2DModel || window.PIXI?.live2d?.Live2DModel;

                if (!Live2DModel) {
                    throw new Error('Live2DModel not found. Check CDN loading.');
                }

                model = await Live2DModel.from(MODEL_PATH);

                // Store original dimensions BEFORE any scaling
                originalModelWidth = model.width;
                originalModelHeight = model.height;

                // Apply proper scaling
                scaleModel();

                app.stage.addChild(model);

                loadingEl.style.display = 'none';
                isReady = true;

                console.log('[Avatar] ‚úÖ Model loaded');
                showStatus('Avatar hazƒ±r!');

                // Animation loop
                app.ticker.add(() => {
                    const now = performance.now();
                    const dt = (now - lastTime) / 1000;
                    lastTime = now;
                    update(dt);
                });

                // Mouse tracking
                document.addEventListener('mousemove', onMouseMove);

            } catch (error) {
                console.error('[Avatar] ‚ùå Error:', error);
                loadingEl.innerHTML = `
                    <div class="error">‚ùå Model y√ºklenemedi</div>
                    <div style="font-size: 12px; margin-top: 10px; max-width: 300px;">${error.message}</div>
                `;
            }
        }

        // Store original model dimensions (before any scaling)
        let originalModelWidth = 0;
        let originalModelHeight = 0;

        function scaleModel() {
            if (!model || !app || !originalModelHeight) return;

            // Calculate scale to fit avatar in window with consistent proportions
            // Use height as the primary constraint
            const targetHeight = app.screen.height * AVATAR_HEIGHT_RATIO;
            const scale = targetHeight / originalModelHeight;

            model.scale.set(scale);
            model.anchor.set(0.5, 0.5);
            model.x = app.screen.width / 2;
            model.y = app.screen.height / 2;
        }

        function onMouseMove(e) {
            // Normalize mouse position to 0-1
            mouseX = e.clientX / window.innerWidth;
            mouseY = e.clientY / window.innerHeight;

            // Convert to -1 to 1 range, centered
            targetEyeX = (mouseX - 0.5) * 2;  // -1 to 1
            targetEyeY = (mouseY - 0.5) * 2;  // -1 to 1

            // Head follows mouse but with less intensity
            targetHeadX = targetEyeX * 15; // Max ¬±15 degrees
            targetHeadY = targetEyeY * 10; // Max ¬±10 degrees
        }

        function update(dt) {
            if (!isReady || !model) return;

            idleTime += dt;

            // Lip sync
            currentMouthValue += (targetMouthValue - currentMouthValue) * Math.min(15 * dt, 1);
            setParam('ParamMouthOpenY', currentMouthValue);

            // Blink
            blinkTimer += dt;
            if (blinkTimer >= nextBlinkTime) {
                doBlink();
                blinkTimer = 0;
                nextBlinkTime = 2.5 + Math.random() * 3;
            }

            // Mouse tracking - smooth interpolation
            const trackSpeed = 5 * dt;
            currentEyeX += (targetEyeX - currentEyeX) * Math.min(trackSpeed, 1);
            currentEyeY += (targetEyeY - currentEyeY) * Math.min(trackSpeed, 1);
            currentHeadX += (targetHeadX - currentHeadX) * Math.min(trackSpeed * 0.5, 1);
            currentHeadY += (targetHeadY - currentHeadY) * Math.min(trackSpeed * 0.5, 1);

            // Apply eye ball position (following mouse)
            setParam('ParamEyeBallX', currentEyeX);
            setParam('ParamEyeBallY', currentEyeY * 0.5); // Less vertical movement

            // Apply head angle (following mouse + idle motion)
            const idleX = Math.sin(idleTime * 0.3) * 3;
            const idleY = Math.sin(idleTime * 0.4) * 2;
            const idleZ = Math.sin(idleTime * 0.2) * 4;

            setParam('ParamAngleX', currentHeadX + idleX);
            setParam('ParamAngleY', currentHeadY + idleY);
            setParam('ParamAngleZ', idleZ);

            // Body idle animation - breathing and sway
            const breathCycle = Math.sin(idleTime * 1.2) * 0.5; // Faster breathing
            const bodySway = Math.sin(idleTime * 0.4) * 2;
            setParam('ParamBodyAngleX', currentHeadX * 0.2 + bodySway);
            setParam('ParamBodyAngleY', breathCycle);
            setParam('ParamBodyAngleZ', Math.sin(idleTime * 0.15) * 1.5);

            // Arm subtle movement
            const armIdle = Math.sin(idleTime * 0.5) * 0.1;
            setParam('ParamArmLA', armIdle);
            setParam('ParamArmRA', -armIdle);

            // Hair physics simulation (if params exist)
            setParam('ParamHairFront', Math.sin(idleTime * 0.7) * 0.3);
            setParam('ParamHairSide', Math.sin(idleTime * 0.6 + 0.5) * 0.2);
            setParam('ParamHairBack', Math.sin(idleTime * 0.5 + 1) * 0.25);
        }

        function setParam(name, value) {
            if (!model?.internalModel?.coreModel) return;
            try {
                const cm = model.internalModel.coreModel;
                const idx = cm.getParameterIndex(name);
                if (idx >= 0) cm.setParameterValueByIndex(idx, value);
            } catch (e) { }
        }

        function doBlink() {
            const duration = 150;
            const start = performance.now();

            function animate(now) {
                const p = (now - start) / duration;
                let v = p < 0.5 ? 1 - p * 2 : (p - 0.5) * 2;
                if (p >= 1) v = 1;

                setParam('ParamEyeLOpen', v);
                setParam('ParamEyeROpen', v);

                if (p < 1) requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }

        function setMouthOpen(val) {
            targetMouthValue = Math.max(0, Math.min(1, val));
        }

        async function playGesture(name, intensity = 0.7) {
            console.log('[Avatar] üé≠ Gesture:', name);

            const gestures = {
                wave: async () => {
                    for (let i = 0; i < 6; i++) {
                        setParam('ParamArmRA', 0.5 + Math.sin(i * Math.PI / 2) * 0.3 * intensity);
                        await sleep(100);
                    }
                    setParam('ParamArmRA', 0);
                },
                nod: async () => {
                    for (let i = 0; i < 4; i++) {
                        setParam('ParamAngleY', Math.sin(i * Math.PI) * 15 * intensity);
                        await sleep(150);
                    }
                },
                shake_head: async () => {
                    for (let i = 0; i < 6; i++) {
                        setParam('ParamAngleX', Math.sin(i * Math.PI) * 20 * intensity);
                        await sleep(100);
                    }
                },
                smile: async () => {
                    setParam('ParamMouthForm', intensity);
                    await sleep(2000);
                    setParam('ParamMouthForm', 0);
                },
                think: async () => {
                    setParam('ParamEyeBallX', 0.5 * intensity);
                    setParam('ParamEyeBallY', 0.3 * intensity);
                    await sleep(2000);
                    setParam('ParamEyeBallX', 0);
                    setParam('ParamEyeBallY', 0);
                },
                excited: async () => {
                    for (let i = 0; i < 8; i++) {
                        setParam('ParamBodyAngleX', Math.abs(Math.sin(i * Math.PI / 2)) * 10 * intensity);
                        setParam('ParamMouthForm', 0.8 * intensity);
                        await sleep(80);
                    }
                    setParam('ParamMouthForm', 0);
                },
                surprised: async () => {
                    setParam('ParamEyeLOpen', 1.3);
                    setParam('ParamEyeROpen', 1.3);
                    await sleep(600);
                    setParam('ParamEyeLOpen', 1);
                    setParam('ParamEyeROpen', 1);
                }
            };

            if (gestures[name]) await gestures[name]();
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        function showStatus(text) {
            const s = document.getElementById('status');
            s.textContent = text;
            s.classList.add('visible');
            setTimeout(() => s.classList.remove('visible'), 3000);
        }

        // Python API
        window.avatarAPI = {
            setMouth: setMouthOpen,
            gesture: playGesture,
            blink: doBlink,
            status: showStatus,
            isReady: () => isReady
        };
        window.setMouth = setMouthOpen;
        window.playGesture = playGesture;

        // Resize - recalculate scale
        window.addEventListener('resize', () => {
            if (app) {
                app.renderer.resize(window.innerWidth, window.innerHeight);
                scaleModel();
            }
        });

        init();
    </script>
</body>

</html>